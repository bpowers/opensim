#===--- output_pretty.py - pretty print an opensim model -----------------===#
#
# Copyright 2009 Bobby Powers
#
# This file is part of OpenSim.
#
# OpenSim is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenSim is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with OpenSim.  If not, see <http://www.gnu.org/licenses/>.
#
#===-----------------------------------------------------------------------===#
#
# This file contains the class to pretty print a model AST.
#
#===-----------------------------------------------------------------------===#

import logging

log = logging.getLogger('opensim.pretty')

CLASS_NAME = 'PrettyPrint'

py_header = """
#!/usr/bin/env python
# python model auto-generated by OpenSim
import math

def frange(lim_start, lim_end, increment = 1.):
  '''
  Range function that allows floating point range increments.

  Standard python range function doesn't allow floating point
  increments in ranges.
  '''
  lim_start = float(lim_start)
  count = int(math.ceil(lim_end - lim_start)/increment + 1)
  return (lim_start + n*increment for n in range(count))


# simple lookup table implementation
def lookup(table, index):
  '''
  Simple lookup table implementation.

  Table takes the format of a list of 2-tuples.
  '''

  if len(table) is 0: return 0

  # if the request is outside the min or max, then we return
  # the nearest element of the array
  if   index < table[0][0]:  return table[0][1]
  elif index > table[-1][0]: return table[-1][1]

  for i in range(0, len(table)):
    x, y = table[i]

    if index == x: return y
    if index < x:
      # slope = deltaY/deltaX
      slope = (y - table[i-1][1])/(x - table[i-1][0])
      return (index-table[i-1][0])*slope + table[i-1][1]

"""


class PrettyPrint:
  '''
  This class implements the visitor methods needed to pretty print a model.
  '''
  def __init__(self):
    self.space = ''

  def visit_scope(self, node):
    '''
    Visiting a scope node.

    Eventually we will use this to implement namespaces and have stacks
    of variables to lookup in, but for now we just grab the vars from
    the root scope.
    '''
    if node.name == 'root':
      self.vars = node.vars
      print py_header
      print '# initial values and stock initializations'

    node.child.gen(self)


  def visit_list(self, node):
    '''
    Visit a list of statements.
    '''
    for stmt in node.statements:
      stmt.gen(self)


  def visit_euler(self, node):
    '''
    Visit a euler integration node.

    This is basically a glorified loop, but is used to distinguish
    between a basic loop and a more complicated RK one.
    '''
    print '\n# variables related to outputting results'
    print 'save_count = 0'
    print 'save_iterations = time_savestep / time_step'
    print 'do_save = True'

    print '\nfor time in frange(time_start, time_end, time_step):'

    #start = self.vars['time_start'].props.equation.strip()
    #end = self.vars['time_end'].props.equation.strip()
    #step = self.vars['time_step'].props.equation.strip()

    # indent things!
    self.space = self.space + '  '
    print '  # calculate flows:'
    node.body.gen(self)

    print '\n  # update stocks:'
    node.stocks.gen(self)

    # determine whether we need to write the next round of output to stdout
    print
    print '  # determining whether or not to save results next iteration'
    print '  save_count += 1'
    print '  if save_count >= save_iterations or time+time_step > time_end:'
    print '    do_save = True'
    print '    save_count = 0'
    print '  else:'
    print '    do_save = False'

    self.space = self.space[:-4]


  def visit_assign(self, node):
    '''
    Visiting an assignment statement.
    '''
    print self.space + node.var_name + ' = ',
    node.value.gen(self)
    print


  def visit_bin_expr(self, node):
    '''
    Visit a node represeting a binary expression.

    We add parentheses becuase when we create the AST we respect
    parenthesis, but they are not represented in the tree
    '''
    print '(',
    node.lval.gen(self)
    print node.op,
    node.rval.gen(self)
    print ')',



  def visit_unary(self, node):
    print node.op + '(',
    node.lval.gen(self)
    print ')',


  def visit_var_ref(self, node):
    '''
    Visit a variable reference.

    Leaf node!
    '''
    print node.name,


  def visit_value(self, node):
    '''
    Visit a node representing a real number.

    Leaf node!
    '''
    print node.val,

